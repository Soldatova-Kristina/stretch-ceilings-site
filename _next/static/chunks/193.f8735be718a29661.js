(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[193],{4193:(e,r,n)=>{"use strict";n.r(r),n.d(r,{default:()=>v});var t=n(7876),o=n(4232),a=n(9017),i=n(1577),l=n(2414),u=n(1907),s=n(5654),c=n.n(s);let f=e=>{let r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return r?[parseInt(r[1],16)/255,parseInt(r[2],16)/255,parseInt(r[3],16)/255]:[1,1,1]},d=(e,r,n)=>{switch(e){case"top-left":return{anchor:[0,-.2*n],dir:[0,1]};case"top-right":return{anchor:[r,-.2*n],dir:[0,1]};case"left":return{anchor:[-.2*r,.5*n],dir:[1,0]};case"right":return{anchor:[1.2*r,.5*n],dir:[-1,0]};case"bottom-left":return{anchor:[0,1.2*n],dir:[0,-1]};case"bottom-center":return{anchor:[.5*r,1.2*n],dir:[0,-1]};case"bottom-right":return{anchor:[r,1.2*n],dir:[0,-1]};default:return{anchor:[.5*r,-.2*n],dir:[0,1]}}},v=e=>{let{raysOrigin:r="top-center",raysColor:n="#ffffff",raysSpeed:s=1,lightSpread:v=1,rayLength:m=2,pulsating:g=!1,fadeDistance:y=1,saturation:h=1,followMouse:p=!0,mouseInfluence:C=.1,noiseAmount:x=0,distortion:R=0,className:w=""}=e,b=(0,o.useRef)(null),D=(0,o.useRef)(null),S=(0,o.useRef)(null),A=(0,o.useRef)({x:.5,y:.5}),P=(0,o.useRef)({x:.5,y:.5}),E=(0,o.useRef)(null),T=(0,o.useRef)(null),I=(0,o.useRef)(null),[L,_]=(0,o.useState)(!1),F=(0,o.useRef)(null);return(0,o.useEffect)(()=>{if(b.current)return F.current=new IntersectionObserver(e=>{_(e[0].isIntersecting)},{threshold:.1}),F.current.observe(b.current),()=>{F.current&&(F.current.disconnect(),F.current=null)}},[]),(0,o.useEffect)(()=>{if(L&&b.current)return I.current&&(I.current(),I.current=null),(async()=>{if(!b.current||(await new Promise(e=>setTimeout(e,10)),!b.current))return;let e=new a.A({dpr:Math.min(window.devicePixelRatio,2),alpha:!0});S.current=e;let t=e.gl;for(t.clearColor(0,0,0,0),t.canvas.style.width="100%",t.canvas.style.height="100%",t.canvas.style.background="transparent";b.current.firstChild;)b.current.removeChild(b.current.firstChild);b.current.appendChild(t.canvas);let o={iTime:{value:0},iResolution:{value:[1,1]},rayPos:{value:[0,0]},rayDir:{value:[0,1]},raysColor:{value:f(n)},raysSpeed:{value:s},lightSpread:{value:v},rayLength:{value:m},pulsating:{value:+!!g},fadeDistance:{value:y},saturation:{value:h},mousePos:{value:[.5,.5]},mouseInfluence:{value:C},noiseAmount:{value:x},distortion:{value:R}};D.current=o;let c=new i.l(t),w=new l.B(t,{vertex:"\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n  vUv = position * 0.5 + 0.5;\n  gl_Position = vec4(position, 0.0, 1.0);\n}",fragment:"precision highp float;\n\nuniform float iTime;\nuniform vec2  iResolution;\n\nuniform vec2  rayPos;\nuniform vec2  rayDir;\nuniform vec3  raysColor;\nuniform float raysSpeed;\nuniform float lightSpread;\nuniform float rayLength;\nuniform float pulsating;\nuniform float fadeDistance;\nuniform float saturation;\nuniform vec2  mousePos;\nuniform float mouseInfluence;\nuniform float noiseAmount;\nuniform float distortion;\n\nvarying vec2 vUv;\n\nfloat noise(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,\n                  float seedA, float seedB, float speed) {\n  vec2 sourceToCoord = coord - raySource;\n  vec2 dirNorm = normalize(sourceToCoord);\n  float cosAngle = dot(dirNorm, rayRefDirection);\n\n  float distortedAngle = cosAngle + distortion * sin(iTime * 2.0 + length(sourceToCoord) * 0.01) * 0.2;\n  \n  float spreadFactor = pow(max(distortedAngle, 0.0), 1.0 / max(lightSpread, 0.001));\n\n  float distance = length(sourceToCoord);\n  float maxDistance = iResolution.x * rayLength;\n  float lengthFalloff = clamp((maxDistance - distance) / maxDistance, 0.0, 1.0);\n  \n  float fadeFalloff = clamp((iResolution.x * fadeDistance - distance) / (iResolution.x * fadeDistance), 0.5, 1.0);\n  float pulse = pulsating > 0.5 ? (0.8 + 0.2 * sin(iTime * speed * 3.0)) : 1.0;\n\n  float baseStrength = clamp(\n    (0.45 + 0.15 * sin(distortedAngle * seedA + iTime * speed)) +\n    (0.3 + 0.2 * cos(-distortedAngle * seedB + iTime * speed)),\n    0.0, 1.0\n  );\n\n  return baseStrength * lengthFalloff * fadeFalloff * spreadFactor * pulse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n  \n  vec2 finalRayDir = rayDir;\n  if (mouseInfluence > 0.0) {\n    vec2 mouseScreenPos = mousePos * iResolution.xy;\n    vec2 mouseDirection = normalize(mouseScreenPos - rayPos);\n    finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));\n  }\n\n  vec4 rays1 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349,\n                           1.5 * raysSpeed);\n  vec4 rays2 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234,\n                           1.1 * raysSpeed);\n\n  fragColor = rays1 * 0.5 + rays2 * 0.4;\n\n  if (noiseAmount > 0.0) {\n    float n = noise(coord * 0.01 + iTime * 0.1);\n    fragColor.rgb *= (1.0 - noiseAmount + noiseAmount * n);\n  }\n\n  float brightness = 1.0 - (coord.y / iResolution.y);\n  fragColor.x *= 0.1 + brightness * 0.8;\n  fragColor.y *= 0.3 + brightness * 0.6;\n  fragColor.z *= 0.5 + brightness * 0.5;\n\n  if (saturation != 1.0) {\n    float gray = dot(fragColor.rgb, vec3(0.299, 0.587, 0.114));\n    fragColor.rgb = mix(vec3(gray), fragColor.rgb, saturation);\n  }\n\n  fragColor.rgb *= raysColor;\n}\n\nvoid main() {\n  vec4 color;\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor  = color;\n}",uniforms:o}),L=new u.e(t,{geometry:c,program:w});T.current=L;let _=()=>{if(!b.current||!e)return;e.dpr=Math.min(window.devicePixelRatio,2);let{clientWidth:n,clientHeight:t}=b.current;e.setSize(n,t);let a=e.dpr,i=n*a,l=t*a;o.iResolution.value=[i,l];let{anchor:u,dir:s}=d(r,i,l);o.rayPos.value=u,o.rayDir.value=s},F=r=>{if(S.current&&D.current&&T.current){o.iTime.value=.001*r,p&&C>0&&(P.current.x=.92*P.current.x+.07999999999999996*A.current.x,P.current.y=.92*P.current.y+.07999999999999996*A.current.y,o.mousePos.value=[P.current.x,P.current.y]);try{e.render({scene:L}),E.current=requestAnimationFrame(F)}catch(e){console.warn("WebGL rendering error:",e);return}}};window.addEventListener("resize",_),_(),E.current=requestAnimationFrame(F),I.current=()=>{if(E.current&&(cancelAnimationFrame(E.current),E.current=null),window.removeEventListener("resize",_),e)try{let r=e.gl.canvas,n=e.gl.getExtension("WEBGL_lose_context");n&&n.loseContext(),r&&r.parentNode&&r.parentNode.removeChild(r)}catch(e){console.warn("Error during WebGL cleanup:",e)}S.current=null,D.current=null,T.current=null}})(),()=>{I.current&&(I.current(),I.current=null)}},[L,r,n,s,v,m,g,y,h,p,C,x,R]),(0,o.useEffect)(()=>{if(!D.current||!b.current||!S.current)return;let e=D.current,t=S.current;e.raysColor.value=f(n),e.raysSpeed.value=s,e.lightSpread.value=v,e.rayLength.value=m,e.pulsating.value=+!!g,e.fadeDistance.value=y,e.saturation.value=h,e.mouseInfluence.value=C,e.noiseAmount.value=x,e.distortion.value=R;let{clientWidth:o,clientHeight:a}=b.current,i=t.dpr,{anchor:l,dir:u}=d(r,o*i,a*i);e.rayPos.value=l,e.rayDir.value=u},[n,s,v,r,m,g,y,h,C,x,R]),(0,o.useEffect)(()=>{let e=e=>{if(!b.current||!S.current)return;let r=b.current.getBoundingClientRect();A.current={x:(e.clientX-r.left)/r.width,y:(e.clientY-r.top)/r.height}};if(p)return window.addEventListener("mousemove",e),()=>window.removeEventListener("mousemove",e)},[p]),(0,t.jsx)("div",{ref:b,className:"".concat(c().lightRaysContainer," ").concat(w).trim()})}},5654:e=>{e.exports={lightRaysContainer:"LightRays_lightRaysContainer__N63m4"}}}]);